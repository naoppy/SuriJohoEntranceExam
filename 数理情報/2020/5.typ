#import "../../template.typ": mytemplate, overview, warning, opt_problem, diag, numeq
#import "@preview/ctheorems:1.1.2": *
#show: thmrules.with(qed-symbol: $square$)
#show: doc => mytemplate(2020, 5, "Naoki Otani", "算法", "lunatic", doc)

#let lemma = thmbox("lemma", "Lemma", fill: rgb("#eeffee"), base_level: 0)
#let theorem = thmbox("theorem", "Theorem", fill: rgb("#eeffee"), base_level: 0)
#let proof = thmproof("proof", "Proof")
#let algo = thmbox("algo", "Algorithm", fill: rgb("#eeffee"), base_level: 0)
#let coro = thmbox("corollary", "Corollary", base_level: 0, inset: (x: 1.2em))

#overview[
  非常に難しい。作問者は (1-2) を誘導にしたかったのだと思うが、誘導が雑なため、普通の人は正しく誘導されず、まちがった方針に誘導されてしまうだろう。
  目的関数が二次関数なので解析的に頑張れてしまうことが、(1-2) の誘導が誘導になっていない原因である。算法の問題であることを意識して解こう。

  これを解いても勉強にはならないが、興味がある人は見てみればいいだろう。
  ちなみに、この問題は Isotonic Regressionと呼ばれる問題で多くの派生問題があり、50年代から研究されている。SOSA2019というシンポジウムでこの問題をDPで解く論文が発表され、それがそのまま2019年8月の試験問題になっている。

  競技プログラミングをかなりやっている人ならば、この問題を知っている人がいるかもしれない。競技プログラミングの文脈では slope trickと呼ばれている。
]

以降、以下の記号を用いる。

$
d_n (A, B) = sum_(i=1)^n (A[i] - B[i])^2
$

== (1-1)
まず、この問題の解は一意であることを示す。


#align(center, 
  opt_problem($ sum_(i=1)^n (A_i - B_i)^2 $, $ B_1 <= B_2 <= dots.c <= B_n $, maximize: false, variables: $B_1, dots, B_n$),
)
は以下のように狭義凸な二次計画問題 (Convex Quadratic Programming) として定式化できる。

#align(center, 
  opt_problem(
    $
    1/2 bold(b)^T I bold(b) - 2 bold(a)^T bold(b)
    $,
    $
    mat(-1, 1, 0, 0, dots.c, 0;
    0, -1, 1, 0, dots.c, 0;
    0, 0, -1, 1, dots.c, 0;
    dots.v, , , , dots.down, ;
    0, 0, dots.c, 0, -1, 1) bold(b) <= mat(0;0;dots.v;0;0)
    $,
    maximize: false, variables: $B_1, dots, B_n$
  ),
)
実行可能領域は多面体より凸集合を成す。目的関数は正定値対称 $I succ O$ より、目的関数は凸関数。よって最適解は一意である。最適解が一意であることがわかったので、最適性の十分性だけ示す。

問題文で与えられている単調非減少配列を $C$ とする。すなわち、$C[i] = B[i] quad (1 <= i <= n), C[n+1] = A'[n+1]$ とする。このとき、$d_(n+1)(A', C) = d_n (A, B)$ である。
一方で、$A'$ に対する最適な単調非減少配列が $D$ で、$C$ は最適ではない $d_(n+1)(A', D) < d_(n+1)(A', C)$ とすると、
$ d_n (A, D "から末尾を削ったもの") <= d_(n+1)(A', D) < d_(n+1)(A', C) = d_n (A, B) $  
これは $B$ の $A$ に対する最適性に矛盾する。よって $C$ は最適である。

== (1-2)
解析的な証明を与える。この証明は重要でなく、もっと簡潔で (2) と関連する証明があるので読み飛ばして構わない。この証明を読んだところで (2) は解けない。

記号を定義する。

$
a_r := 1/r sum_(i=1)^r A'[i] quad "(先頭" r "個の平均)"
$

いくつか補題を示す。


#lemma[
  $A$ に対する近似配列 $B$ が、ある $r$ $(1 <= r <= n)$ で、$B[1] = dots.c = B[r]$ の制約があり、$B[r+1]$ 以降の要素は既に決まっているとする。\
  このとき、$B[r+1] >= a_r$ ならば、$B[1] = dots.c = B[r] = a_r$ とするのが最適である。
  $B[r+1] < a_r$ ならば、$B[1] = dots.c = B[r] = B[r+1]$ とするのが最適である。
] <Lem1>
#proof[
  $d_r (A, c) = sum_(i=1)^r (A[i] - c)^2$ を $c$ で微分することで、最小化する定数 $c$ は $a_r$ であることがわかる。$d_r (A, c)$ が $c$ に対する二次関数なので、$B[r+1] < a_r$ の場合もできるだけ $a_r$ に近い場所が最適である。これは $c = B[r + 1]$ を意味する。
]

#lemma[
  長さ $n$ の配列 $A$ に対して、最適な近似配列 $B$ が $B[1] = dots.c = B[n]$ であるとする。\
  このとき、$a_r >= a_n thick (1 <= r <= n)$
] <Lem2>
#proof[
  @Lem1 より、$B[1] = dots.c = B[n] = a_n$ である。もし、$B[1] = dots.c = B[r] = c eq.not a_r$ と変更しても、$B$ の最適性より悪化しかしない。@Lem1 より、$a_r < a_n$ ならば $c = a_r$ とすると改善してしまうので、$a_r >= a_n$ である。
]

準備は終わったので、示していく。

#theorem[
  $B[1] = dots.c = B[n]$ かつ $A'[n+1] < B[n]$ とする。このとき、$B'[1] = dots.c = B'[n + 1]$ かつ $B'[n+1] < B[n]$
] <Thm1>
#proof[
  @Lem1 より、$B[1] = dots.c = B[n] = a_n$ である。さらに問題文より、
  $ b_(n+1) = 1/(n+1) A'[n+1] + n/(n+1) a_n < 1/(n+1) B[n] + n/(n+1) a_n = a_n $
  であり、@Lem2 と合わせて、$a_r >= a_n > a_(n+1) thick (1 <= r <= n)$。
  
  さて、$B'$ の最後の変化点について考える。$B'[1] = dots.c = B'[r] < B'[r+1]$ なる最後(最初?)の変化点 $r thick (1 <= r <= n-1)$ が存在するとする。
  @Lem1 より、変化点が存在するならば、そこでは $B'[1] = dots.c = B'[r] = a_r < B'[r+1]$ でなくてはいけない。$B'$ は単調非減少なので、$B'[r+1] <= B'[n] <= B'[n+1]$。
  よって、$ B'[n+1] >= B'[n] >= B'[r+1] > a_r >= a_n $ だが、これは $B$ の最適性に反する。長さ $n$ の近似配列は $B[i] = a_n$ が最適で、$B'[n+1] > a_n$ なので実行可能解に入っている。よって矛盾。 $r = n$ か $r = n+1$ であるが、$r = n$ のときは明らかに $B'[n+1]$ をより小さくして $B'[n+1] = B'[n]$ にしたほうが改善するので、$r = n$ ではない。
  よって、$r = n+1$ であり、$B'[1] = dots.c = B'[n+1]$。@Lem1 より、$B'[1] = dots.c = B'[n+1] = a_(n+1) < a_n = B[n]$ より、示された。
]


== (2)
以下の議論は全て参考文献の論文の受け売りなので、わからないところがあれば参考文献を読んでみるといいだろう。

さて、まずは区分二次凸関数(piecewise quadratic convex function)という概念を導入する。
区分二次凸関数とは、関数が有限個の全ての区間(非有界な区間でも可)において二次関数になっており、全体で見ると凸関数である関数のことである。
定義から、区分二次関数に二次関数を足しても区分二次関数であり、さらに、区分二次凸関数に凸な二次関数を足しても区分二次凸関数である。

では、以下の部分問題を考える。

$
f_k (x) = min{ sum_(i=1)^k (B_i - A_i)^2 mid(|) B_1 <= B_2 <= dots.c <= B_k = x }
$
定義から簡単に以下がわかる。
$
f_k (x) &:= min { f_(k-1) (z) mid(|) z <= x } + (x - A_k)^2 \
f_1 (x) &:= (x - A_1)^2
$

#lemma[
  1. $f_k$ は区分二次凸関数である
  2. $f_k$ の区間は最大 $k$ 個
  3. 最も右の区間の二次関数は $x^2 - 2 A_k x + c thick (c "は適当な定数")$ で、最も左の区間の二次関数は $k x^2 - 2 (sum_(i=1)^k A_i) x + c' thick (c' "は適当な定数")$
] <Lem3>
#proof[
  $ g_(k-1) (x) := min{ f_(k-1)(z) mid(|) z <= x } $
  と定義する。
  補題の主張は $k=1$ で自明に成り立つ。$f_(k-1)$ で成り立つとする。すると凸性より、$f_k (x)$ は最初は単調減少し、ある点からは単調増加する。$p_(k-1)$ をそのような $f_(k-1) (x)$ の最小値を与える点とする。すると、$g_(k-1) (x)$ は、$x <= p_(k-1)$ で $z = x$ が最適で、$g_(k-1) (x) = f_(k-1) (x)$。$x >= p_(k-1)$ では $z = p_(k-1)$ が最適であり、$g_(k-1) (x) = f_(k-1) (p_(k-1))$。
  よって、 $g_(k-1) (x)$ は $f_(k-1) (x)$ と同じ単調減少する区間を持ち、単調増加する区間は全て定数関数(従って二次関数でもある) $g_(k-1)(x >= p_(k-1)) = f_(k-1) (p_(k-1))$ に置き換えられている。つまり、$g_(k-1)$ は最大 $k$ 個の区間を持つ、区分二次な広義凸関数である。
  $f_k (x) = g_k (x) + (x - A_k)^2$ より、$f_k (x)$ は最大 $k$ 個の区間を持つ区分二次凸関数である (区間ごとの二次関数の形に $x^2 - 2 A_k x + A_k^2$ が足されるため)。最も右の区間は、$g_(k-1) (x)$ の最右区間が定数関数だったことから従う。最も左の区間も同様に、帰納法の仮定と $g_(k-1) (x)$ の形から従う。
]
さて、元の問題は $min {f_n (z) | z <= infinity}$ であるので、$min$ を達成する $z = p_n = B_n$ である。そして、$B_k, dots, B_n$ が分かっているとき、$min {f_(k-1) (z) | z <= B_k}$ の解 $z$ は、$min(p_(k-1), B_k)$ である。以上より、$p_1, dots, p_n$ を求めれば元の問題の解は構成できる。

ここまで示したことを図でもう一度説明する。

#figure(
  image("5figs/f1.png", width: 60%),
  caption: [$f_1 (x) = (x - 30)^2$ のときの $f_1 (x), g_1(x), p_1$ の例]
)
#figure(
  image("5figs/f2.png", width: 60%),
  caption: [$f_2 (x) = g_1 (x) + (x - 70)^2$ の例。各区間ごとに二次関数を足せばよい。元々全ての区間は二次関数なので、足した結果、すべての区間は二次関数。また、$g_(k-1)$ は凸なので凸関数である $(x-70)^2$ を足した $f_k$ も凸であることがわかる。]
)
#figure(
  image("5figs/g2.png", width: 60%),
  caption: [$g_2 (x)$ の例。]
)
$A_1 = 30, A_2 = 70$ の例だが、$A_3 = 50$ であれば $f_3, g_3$ はどのようになるか？$p_1, p_2$ とは違い、$p_3$ は最も右の区間に現れるとは限らないであろう。
さて、これで基本的な説明は終わった。
次の問題は、この区間とそこでの関数をどのように表現するかである。区間は被りがないので、各区間の端点とその区間での二次関数の係数 $a x^2 + b x + c$ の $(a, b, c)$ を保存すればよい。二次関数が足されるときはそのまま係数同士を足せばよいし、最小な点 $p_k$ を求めるときは、各区間の二次関数の最小点 $x = - b / (2a)$ を求めて、それが区間内に入っていればそれが最小点である。入っていなければ、関数は全体で見ると凸なので、隣の区間を順番に探索していけばよい。

それではアルゴリズムを与える。

#import "@preview/lovelace:0.3.0": *
#pseudocode-list(indentation: 1.3em, booktabs: true, title: [Algorithm 1])[
  + Q $:= emptyset; thick$ \/\/ 区間の左端をキーとする優先度付きキュー
  + Q.insert($(-infinity, infinity), (0, 0, 0)$); \/\/ 区間 $(-infinity, infinity)$ は $0x^2 + 0x + 0$
  + *for* $k = 1, dots, n$ *do*
    + \/\/ $g_(k-1)$ から開始
    + *for* all q $in$ Q *do*
      + $q$ の係数に $x^2 - 2 A_k x + A_k^2$ を足す;
    + Obj $:=$ Q.findmax; \/\/ 最も右の区間から見ていく
    + *while* $-("Obj.b") / (2 "Obj.a") < "Obj.left"$ *do*
      + Q.deletemax;
      + Obj $:=$ Q.findmax;
    + $p_k := -("Obj.b") / (2 "Obj.a")$
    + *if* Obj.left $!= p_k$ *do* \/\/ 幅0の区間が生まれるのを防ぐ
      + Obj.right $:= p_k$;
      + Q.insert($(p_k, infinity), (0, 0, "Obj.a" p_k^2 + "Obj.b" p_k + "Obj.c")$); \/\/ $p_k$ より右は定数関数
    + *else*
      + Obj $:= ((p_k, infinity), (0, 0, "Obj.a" p_k^2 + "Obj.b" p_k + "Obj.c"))$;
      
      
  + \/\/ $B_k$ を求めていく
  + $B_n := p_n$
  + *for* $k := n - 1, n-2, dots, 1$ *do*
    + $B_k := min(p_k, B_(k+1))$
]

以下は補足であるが、実はこのアルゴリズムはさらに高速化できる。
まず、優先度付きキューはスタックに変更できる。何故なら区間を右側から順番に見ていくか、最も右の区間に定数関数を追加することしかしていない。

次に、区分二次関数を表現する方法について考える。区間内における定数項 $c$ については $p_k$ を求めるときに関与しない。よって持つ係数は実は $a, b$ のみでよい。
さらに、区間の係数を持つのではなく、区間の区分点において、左右の係数の差を持つようにすればよい。こうすると区間に二次関数を足すとき、最も右の区間の係数を増やすだけでよくなる。これは競技プログラミングの文脈では slope trick と呼ばれるテクニックである。
このような高速化をすると全体で $O(n)$ になる。とはいえこれらのテクニックを使わず愚直に実装しても $O(n^2)$ で多項式時間なので、問題に解答する分には十分であるが、この slope trick が論文の本質的な内容のため、紹介しておいた。

// 以下、解けそうで解けなかった嘘証明。最後の部分で嘘があるので注意。途中までは正しい。
/*
@Thm1 から得られる系を示す。
#coro[
  長さ $n$ の配列 $A$ の前方 $m$ 個の部分列 $A[1], dots, A[m]$ に対する近似配列が $B$ で、$B[1] = dots.c = B[m] = b$ かつ、$B[m] > A[m+1] = dots.c = A[n] = a$ ならば、$A$ の近似配列 $B'$ は $B'[1] = dots.c = B'[n] = m/n b + (n-m)/n a$ である。
]
#proof[
  @Thm1 を使って $A[m+1]$ から $A[n]$ まで順番に付け足せばよい。毎回の付け足しで近似配列は常に定値かつその値は単調に減少していくが、$a$ より小さくはならないので同じ議論を繰り返すことができる。
]

/*
次に、自明ではあるが以下が成り立つ。
#theorem[
  長さ $n$ の配列 $A_1$ に対する近似配列が $B_1$ で、長さ $m$ の配列 $A_2$ に対する近似配列が $B_2$ とする。
  このとき $B_1[n] <= B_2[1]$ ならば、$A_1$ と $A_2$ を繋げた長さ $n+m$ の配列の近似配列は、$B_1$ と $B_2$ を繋げたものである。
]

この逆は当然成り立たないのだが、少し仮定を強めると、以下が成り立つ。*/

次に補題を示す。
#lemma[
  $A$ の近似配列が $B$ とする。このとき、
  $
  sum_(i=1)^n A[i] = sum_(i=1)^n B[i]
  $
]
#proof[
  $B[i]$ に一様に $delta$ を加えた配列 $B'$ を考える。$delta$ は正も負もありうる。
  $B$ の最適性より、
  $
  d(A, B') >= d(A, B) quad (forall delta)
  &<=> sum_(i=1)^n (A[i] - (B[i] + delta))^2 - sum_(i=1)^n (A[i] - B[i])^2 >= 0 quad (forall delta)\
  &<=> n delta^2 - 2 delta (sum_i A[i] - sum_i B[i]) >= 0 quad (forall delta)\
  &<=> sum_i A[i] - sum_i B[i] = 0
  $
  最後は $delta$ の二次関数であることから従う。
]
#coro[
  上の系として、
  $
  B[1] <= 1/n sum_(i=1)^n A[i] <= B[n]
  $
  等号は $B[1] = dots.c = B[n]$ のときのみ成り立つ。
] <Cor2>
#proof[
  $B$ の単調性より、$n B[1] <= sum_i B[i] <= n B[n]$ であるため。
]

唐突だが、以下が成り立つ。
#theorem[
  長さ $n$ の配列 $A$ に対する近似配列が $B$ で、$B$ の末尾 $m$ 要素は同じ $B[n-m] < B[n - m + 1] = dots.c = B[n] =: b$ とする。このとき、長さ $m$ の $A$ の末尾部分列 $A[m+1], dots, A[n]$ に対する近似配列は $B$ の末尾定数部分列 $B[m+1], dots, B[n] = b, dots, b$ である。
] <Thm2>
#proof[
  $A$ の末尾 $m$ 個の部分列を $A_s$ と表す。$A_s$ の近似配列を $B_s$ として、これが $B$ の末尾定数部分列 $b, dots, b$ と異なるとして、矛盾を導く。\
  
  1. $B_s [1] < B[n-m]$ を示す。\
    $B_s [1] >= B[n-m]$ とすると、$B[n - m + i] = B_s [i]$ とすると改善する。これは $B$ の最適性に反する。\
  2. $B_s [m] <= B[n]$ を示す。 \
    $B_s [m] > B[n]$ とすると、$B[n - m + i] = max(B[n-m+i], B_s [i])$ にすると改善する。これは $B$ の最適性に反する。\
  
  以上より、$B_s [1] < B[n-m]$ かつ $B_s [m] <= B[n]$ である。\
  ところで、$d(A_s, c)$ を最小化する $c$ は @Lem1 より $c = 1/m A_s [i]$ であったが、これは @Cor2 より $c < B_s [m] <= B[n]$ である。しかし、定数による近似は定数に対して誤差が二次関数的なため、$B[n-m+1] = dots.c = B[n] = max(B[n-m], c)$ と $B[n-m]$ より大きいことを保った上でなるべく $c$ に近づけると $B$ は改善してしまう。これは $B$ の最適性に矛盾する。よって $B_s = B[n-m+i] = dots.c = B[n] = b$ である。
]

以上より、以下のアルゴリズムが考えられる。


#algo[
  長さ $n$ の配列 $A$ に対する近似配列 $B$ が求まっている時に、$A$ の末尾に $A'[n+1]$ を追加した長さ $n+1$ の配列 $A'$ に対する近似配列 $B'$ を求めるアルゴリズムを与える。\
  1. $A'[n+1] >= B[n]$ の場合 \
    (1-1) より、$B'[i] = B[i] thick (forall i), B'[n+1] = A'[n+1]$ とすればよい。\
  2. $A'[n+1] < B[n]$ の場合 \
    $B$ の、同じ値を持つ末尾部分列を取る。すると、@Thm2 より、これは $A$ の末尾部分に対する近似配列であるので (1-2) が適応でき、$A'$ の末尾部分に対する近似配列は (1-2) より $B$ の末尾部分と $A'[n+1]$ の加重平均になる。これを $b'$ とする。
    ここで、$B$ の末尾部分列との接続部分 $r$ において $B[r] < b'$ ならば、$B'[i] = B[i] thick (1 <= i <= r), B'[r+i] = b' thick (i > 0)$ とすればよい。\
    そうではない場合、さらに $B$ の $r$ 以前の末尾定数部分列を更に取ってくる。そして、b' がいくつか繋がったものと更に加重平均をとっていけばよい。
]

以上のアルゴリズムを用いて、$A$ を前から順番にひとつづつ見ていき、$A$ の部分列に対する近似配列を求めるのを繰り返せばよい。
明らかに多項式時間。
*/

今回はDPによる解法について書いたが、それ以外の解法も実に多様な手法が提案されている。
(2) は二次凸計画問題として定式化できるので楕円体法で多項式時間で解けます！ｗでも解答としてはいいかもしれない…。最適化の理論は汎用的で強いですね。

== (1-2) 別解
@Lem3 の証明を読めば自明であると思うが、$B[n] = p_n, B[k-1] = min(p_(k-1), B[k])$ を使うと、$B[1] = B[1] = dots.c = B[n]$ ならば、$p_k >= B[n]$ であることがわかる。よって、$g_n$ の左の区間が $n x^2 - 2 (sum_i A_i) x + sum_i A_i^2$ 、右の区間が定数。となっている。ここに $(x - A_(n+1))^2$ を足すと、定数の区間では最小値を取らないことが自明にわかる。よって $p_(n+1) < p_n$ であるので、$B'[1] = dots.c = B'[n+1] < B[n]$ と簡潔に示せる。

== 間違った解法について
driveやgithubに上がっている、Bをシフトして平らにしたあと (1-2) を適用して、その後戻す。というアルゴリズムは間違っている。$B$ を単調性を持ったシフトをして平らにして、(1-2) を適用するところまでは論理として正しいが、その後戻す部分で最適性が失われてしまう。単調性を持ったシフトに対して最適性は保存されるが、逆のシフトでは失われることに注意する。

#bibliography("5.bib", full: true, title: "参考文献")
